#!/usr/bin/python3

import argparse
import os
import re
import subprocess
import syslog
import time
import traceback

opts = None
log = None

def main():
    parse_args()

    global log
    log = Log()

    if opts.unmountall:
        unmountall()
        return 0

    if opts.add:
        add(opts.add[0])
        return 0

    if opts.provision:
        provision(opts.provision[0], opts.size[0])
        return 0

    if opts.remove:
        remove(opts.remove[0])
        return 0

    return 0

def parse_args(args = None):
    a = argparse.ArgumentParser()
    a.add_argument("-a", "--add", nargs = 1, metavar = "dev",
                   action = "store",
                   help = "add device")
    a.add_argument("-p", "--provision", nargs = 1, metavar = "dev",
                   action = "store",
                   help = "provision device")
    a.add_argument("-s", "--size", nargs = 1, metavar = "size",
                   action = "store", type = int, default = [4000],
                   help = "initial size to provision")
    a.add_argument("-r", "--remove", nargs = 1, metavar = "dev",
                   action = "store",
                   help = "remove device")
    a.add_argument("-u", "--unmountall",
                   action = "store_true",
                   help = "unmount everything")
    a.add_argument("-d", "--daemon",
                   action = "store_true",
                   help = "daemon mode, log to syslog")
    a.add_argument("-n", "--dryrun",
                   action = "store_true",
                   help = "dry run, don't actually do anything")
    a.add_argument("-v", "--verbose",
                   action = "store_true",
                   help = "verbose, log more")

    global opts
    opts = a.parse_args(args)

    if not opts.add and not opts.provision and not opts.remove and \
       not opts.unmountall:
        if os.getenv("SUBSYSTEM") == "block":
            dev = os.getenv("MDEV")
            if dev is not None:
                action = os.getenv("ACTION")
                if action == "add":
                    opts.add = [dev]
                elif action == "remove":
                    opts.remove = [dev]

    if not opts.add and not opts.provision and not opts.remove and \
       not opts.unmountall:
        a.print_help()

def unmountall():
    mnt = "/mnt"
    vmnt = mnt + "/vg00-lv00"
    if os.path.isdir(vmnt):
        run(["umount", vmnt])
        os.rmdir(vmnt)
    run(["lvchange", "-an", "vg00/lv00"], ignoreerr = True)
    for dev in listdir(mnt, "sd[a-z][0-9]+"):
        remove(dev)

def provision(dev, size):
    mnt = "/mnt/" + dev
    dir = mnt + "/prjx/storage/"
    file = dir + "pv0000"
    tmpfile = dir + "tmp0000"

    if size < 1 and size > 4000:
        log.error("size %s must be between 1 and 4000MB" % (size))

    try:
        if not check_partition(dev):
            log.error("can't provision %s" % (dev))
            return
    except Exception:
        return

    run(["mkdir", "-p", mnt])
    try:
        run(["mount", "/dev/" + dev, mnt])
    except Exception:
        log.error("failed to mount %s on %s" % (dev, mnt))
        return
    if os.path.isfile(file):
        run(["umount", mnt])
        os.rmdir(mnt)
        log.error("device %s is already provisioned" % (dev))
        return

    # write in 8MB units
    bs = 8
    blocks = int((size + (bs - 1)) / bs)
    buf = [bytes(256 * 1024)] * (4 * bs)
    fd = None
    try:
        run(["mkdir", "-p", dir])
        log.info("creating partition file %s size %dMB" % (file, blocks * bs))
        flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC | \
                os.O_DSYNC | os.O_DIRECT
        # the 0600 doesn't really do anything on fatfs
        fd = os.open(tmpfile, flags, 0o600)
        log.verbose("writing %d %dMB block(s)" % (blocks, bs))
        for i in range(blocks):
            log.verbose("  %d" % (i))
            os.writev(fd, buf)
    except Exception as e:
        if fd is not None:
            os.ftruncate(fd, 0)
        os.unlink(tmpfile)
        run(["umount", mnt])
        os.rmdir(mnt)
        log.error("failed to create %dMB file %s" % (blocks * bs, tmpfile))
    finally:
        if fd is not None:
            os.close(fd)
        del buf

    log.info("creating physical partition")
    try:
        loopdev = run(["losetup", "-f", "--show", tmpfile]).strip("\n")
    except Exception:
        os.unlink(tmpfile)
        run(["umount", mnt])
        os.rmdir(mnt)
        log.error("failed to create loopback device for file %s" % (tmpfile))
        return

    vdev = "/dev/mapper/vg00-lv00"
    try:
        run(["pvcreate", loopdev])
        log.info("creating volume group")
        run(["vgcreate", "vg00", loopdev])
        log.info("creating logical volume")
        run(["lvcreate", "-an", "-nlv00", "-l100%FREE", "vg00"])
        run(["lvchange", "-ay", "--activationmode", "complete", "vg00/lv00"])
        waitlv(vdev)
    except Exception:
        run(["lvchange", "-an", "vg00/lv00"], ignoreerr = True)
        run(["lvremove", "-y", "vg00/lv00"], ignoreerr = True)
        run(["losetup", "-d", loopdev])
        os.unlink(tmpfile)
        run(["umount", mnt])
        os.rmdir(mnt)
        log.error("failed to create physical partition, volume group, " +
                  "or logical volume")
        return

    vdev = "/dev/mapper/vg00-lv00"
    vdir = "/mnt/vg00-lv00"
    try:
        log.info("creating file system")
        run(["mkfs", "-text4", vdev])
        mountlv1(vdev, vdir)
        os.rename(tmpfile, file)
    except Exception:
        run(["lvchange", "-an", "vg00/lv00"])
        run(["losetup", "-d", loopdev])
        os.unlink(tmpfile)
        run(["umount", mnt])
        os.rmdir(mnt)
        log.error("failed to create or mount filesystem")
        return

def add(dev):
    mnt = "/mnt/" + dev
    dir = mnt + "/prjx/storage/"

    try:
        if not check_partition(dev):
            log.info("ignoring %s" % (dev))
            return
    except Exception:
        return

    log.verbose("adding %s" % (dev))

    # XXX check dev and mnt mount status
    run(["mkdir", "-p", mnt])
    try:
        run(["mount", "/dev/" + dev, mnt])
    except Exception:
        os.rmdir(mnt)
        log.error("failed to mount %s on %s" % (dev, mnt))
        return
    if not os.path.isdir(dir):
        run(["umount", mnt])
        os.rmdir(mnt)
        log.warning("device %s has not been provisioned" % (dev))
        return

    pvs = listdir(dir, "pv[0-9]{4}")
    if len(pvs) == 0:
        run(["umount", mnt])
        os.rmdir(mnt)
        log.warning("device %s doesn't have any partition files" % (dev))
        return

    try:
        loopdevs = []
        for pv in pvs:
            f = dir + pv
            log.verbose("adding physical partition %s" % (f))
            loopdev = run(["losetup", "-f", "--show", f]).strip("\n")
            loopdevs.append(loopdev)
        mountlv()
    except Exception:
        for loopdev in loopdevs:
            run(["losetup", "-d", loopdev])
        run(["umount", mnt])
        os.rmdir(mnt)
        return

def mountlv():
    vdev = "/dev/mapper/vg00-lv00"
    try:
        run(["lvchange", "-ay", "--activationmode", "complete", "vg00/lv00"])
        waitlv(vdev)
    except Exception:
        log.error("failed to activate logical volume")
        raise

    vdir = "/mnt/vg00-lv00"
    try:
        mountlv1(vdev, vdir)
    except Exception:
        run(["lvchange", "-an", "vg00/lv00"])
        raise

def mountlv1(vdev, vdir):
    run(["mkdir", "-p", vdir])
    try:
        run(["mount", vdev, vdir])
    except Exception:
        log.error("failed to mount logical volume %s on %s" % (vdev, vdir))
        os.rmdir(vdir)
        raise
    log.info("logical volume %s mounted on %s" % (vdev, vdir))

def waitlv(vdev, timeout = 5):
    n = timeout * 2
    while not os.path.exists(vdev):
        if n <= 0:
            log.error("timed out waiting for logical volume %s" % (vdev))
            raise RuntimeError()
        # print only every second and don't print the first one
        if n < timeout * 2 and n % 2 == 0:
            log.info("waiting for logical volume %s...%d" % (vdev, n / 2))
        n -= 1
        time.sleep(0.5)

def remove(dev):
    mnt = "/mnt/" + dev
    dir = mnt + "/prjx/storage/"

    try:
        for pv in listdir(dir, "pv[0-9]{4}"):
            loopdev = run_re(["losetup", "-j", dir + pv],
                             "^(/dev/loop[1-9]+):")
            if loopdev is not None:
                run(["losetup", "-d", loopdev])
    except Exception:
        log.error("failed remove a physical partition loopback device")
        return

    time.sleep(1) # XXX
    run(["umount", mnt])
    os.rmdir(mnt)

def check_partition(dev):
    m = re.fullmatch("(sd[a-z])[0-9]+", dev)
    if not m:
        # better partition check
        log.error("%s is not a storage partition" % (dev))
        raise RuntimeError()
    bdev = m.group(1)
    mounted = run_re(["mount"], "^(/dev/(?:%s|%s)) on " % (bdev, dev))
    if mounted is not None:
        log.info("%s is already mounted" % (mounted))
        return False
    return True

def listdir(dir, pattern = None):
    res = []
    for f in os.scandir(dir):
        if pattern is None or re.fullmatch(pattern, f.name):
            res.append(f.name)
    res.sort()
    return res

def run(cmd, stdin = subprocess.DEVNULL, ignoreerr = False,
        alwaysrun = False, quiet = False):
    if not quiet:
        log.verbose("%s" % (" ".join(cmd)))
    if not alwaysrun and opts.dryrun:
        return ""
    s = None
    try:
        s = subprocess.run(cmd, stdin = stdin,
                           stdout = subprocess.PIPE,
                           stderr = subprocess.STDOUT)
        if type(s.stdout) is bytes:
            s.stdout = s.stdout.decode("ASCII")
        s.check_returncode()
    except Exception as e:
        if not ignoreerr:
            if s is None:
                log.error("error from \"%s\": %s" % (" ".join(cmd), e))
            else:
                log.error("error from \"%s\": %s:%s" %
                          (" ".join(cmd), e, s.stdout))
            raise e
    return s.stdout

def run_re(cmd, pattern):
    s = run(cmd, alwaysrun = True, quiet = True)
    m = re.search(pattern, s, re.MULTILINE)
    if not m:
        return None
    return m.group(1)

class Log(object):
    def __init__(self):
        syslog.openlog("storagemgr", 0, syslog.LOG_DAEMON)
    def _log(self, priority, msg):
        for line in msg.split("\n"):
            if line == "":
                continue
            if opts.daemon:
                syslog.syslog(priority, line)
            else:
                print(line)
    def info(self, msg):
        self._log(syslog.LOG_INFO, msg)
    def warning(self, msg):
        self._log(syslog.LOG_WARNING, msg)
    def error(self, msg):
        self._log(syslog.LOG_ERR, msg)
    def verbose(self, msg):
        if not opts.verbose:
            return
        self._log(syslog.LOG_INFO, msg)

if __name__ == "__main__":
    try:
        exit(main())
    except KeyboardInterrupt:
        pass
    except Exception as e:
        log.error(traceback.format_exc())
    exit(1)
