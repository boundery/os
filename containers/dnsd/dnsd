#!/usr/bin/python3

import argparse
import dnslib as dl
import dnslib.server as ds
import socketserver as ss
import json
import requests
import socket
import threading
import time
import syslog
import traceback

opts = None
log = None
zones = {}

def main():
    parse_args()

    global log
    log = Log("dnsd", opts)

    run()

    return 0

def parse_args(args = None):
    a = argparse.ArgumentParser()
    a.add_argument("-f", "--file",
                   action = "store", default = "/etc/dnsd/zones.json",
                   help = "data file name")
    a.add_argument("-p", "--port", type = int,
                   action = "store", default = 54,
                   help = "control socket port number")
    a.add_argument("-a", "--addr",
                   action = "store", default = None,
                   help = "listen address (for debugging only)")
    a.add_argument("-d", "--daemon",
                   action = "store_true",
                   help = "daemon mode, log to syslog")
    a.add_argument("-v", "--verbose",
                   action = "count", default = 0,
                   help = "verbose, log more")

    global opts
    opts = a.parse_args(args)

def run():
    with open(opts.file) as f:
        jzones = json.load(f)
        log.verbose2(json.dumps(jzones, indent = 4))

    intaddr, extaddr, privaddr = getaddrs()

    for addr, port, origin, ttl, data in jzones:
        zone = Zone(origin, ttl, data, addr, port, intaddr, extaddr)
        global zones
        zones[zone.origin] = zone

    for zone in zones.values():
        zone.start()

    ctrl = CtrlServer((privaddr, opts.port))
    ctrl.start()

def getaddrs():
    if opts.addr is not None:
        # XXX only good for debugging
        return opts.addr, opts.addr, opts.addr
    # XXX this is bogus
    addrs = socket.getaddrinfo(socket.gethostname(), 0,
                               socket.AF_INET, socket.SOCK_STREAM)
    assert len(addrs) == 2
    if addrs[0][4][0].startswith("172.18.0."):
        privaddr = addrs[0][4][0]
        intaddr = addrs[1][4][0]
    else:
        assert addrs[1][4][0].startswith("172.18.0.")
        privaddr = addrs[1][4][0]
        intaddr = addrs[0][4][0]

    # XXX temporary
    r = requests.get("http://www.ewxyzzy.net/cgi-bin/addr")
    extaddr = r.text.strip()

    return intaddr, extaddr, privaddr

class Zone(object):
    logger = ds.DNSLogger("request,-request") # don't log

    def __init__(self, origin, ttl, jdata,
                 servaddr, servport, intaddr, extaddr):
        origin = Zone.mklabel(origin)
        self.origin = origin
        self.ttl = ttl
        self.intaddr = intaddr
        self.extaddr = extaddr
        self.servaddr = self.modaddr(servaddr)
        self.servport = servport
        self.lock = threading.Lock()
        self.rds = {}
        for name, jrds in jdata.items():
            name = self.fqdn(name)
            rds = []
            for jrd in jrds:
                rd = self.mkrd(jrd[0], jrd[1:])
                if rd is None:
                    raise RuntimeError("unknown RR type %s" % (jrd[0]))
                rds.append(rd)
            self.rds[name] = rds
        self.resolver = None
        self.udp = None
        self.tcp = None

    def start(self):
        log.info("listening on %s port %s zone %s" %
                 (self.servaddr, self.servport, self.origin))
        self.resolver = Resolver(self)
        self.udp = ds.DNSServer(self.resolver,
                                address = self.servaddr, port = self.servport,
                                tcp = False, logger = self.logger)
        self.udp.start_thread()
        self.tcp = ds.DNSServer(self.resolver,
                                address = self.servaddr, port = self.servport,
                                tcp = True, logger = self.logger)
        self.tcp.start_thread()

    def get(self, label, default):
        return self.rds.get(label, default)

    def set(self, name, type, value):
        name = self.fqdn(name)
        nrd = self.mkrd(type, value)
        if nrd is None:
            return False

        with self.lock:
            ords = self.get(name, [])
            log.verbose("set: old rds %s" % (ords))
            nrds = []
            found = False
            for ord in ords:
                if ord[0] != nrd[0]:
                    nrds.append(ord)
                    continue
                # replace first record of the same type, remove all others
                if not found:
                    nrds.append(nrd)
                    found = True
            # add record if no existing record of the same type
            if not found:
                nrds.append(nrd)
            self.rds[name] = nrds
            log.verbose("set: new rds %s" % (nrds))

        return True

    def mkrd(self, jtype, jvalue):
        jtype = jtype.lower()
        if type(jvalue) is not list:
            jvalue = (jvalue)
        if jtype == "soa":
            return (dl.QTYPE.SOA,
                    dl.SOA(self.fqdn(jvalue[0]),
                           self.fqdn(jvalue[1]),
                           jvalue[2]))
        if jtype == "ns":
            return (dl.QTYPE.NS, dl.NS(self.fqdn(jvalue[0])))
        if jtype == "a":
            return (dl.QTYPE.A, dl.A(self.modaddr(jvalue[0])))
        if jtype == "cname":
            return (dl.QTYPE.CNAME, dl.CNAME(self.fqdn(jvalue[0])))
        if jtype == "mx":
            return (dl.QTYPE.MX, dl.MX(self.fqdn(jvalue[0]), jvalue[1]))
        if jtype == "txt":
            return (dl.QTYPE.TXT, dl.TXT(jvalue[0]))
        if jtype == "ptr":
            return (dl.QTYPE.PTR, dl.PTR(self.fqdn(jvalue[0])))

        return None

    def fqdn(self, name):
        """
        Turn name (a string) into a fully qualified domain name,
        and return it as a DNSLabel.
        """
        if name == "@":
            return self.origin
        if name[-1] == ".":
            return Zone.mklabel(name)
        return self.origin.add(name.lower())

    def mklabel(name):
        return dl.DNSLabel(name.lower())

    def modaddr(self, addr):
        if addr == "*":
            return self.intaddr
        if addr == "**":
            return self.extaddr
        return addr

class Resolver(ds.BaseResolver):
    def __init__(self, zone):
        self.zone = zone

    def resolve(self, request, handler):
        try:
            log.verbose("request:\n%s" % (request))
            reply = self.resolve1(request)
        except Exception as e:
            log.error("%s" % traceback.format_exc())
            reply = request.reply()
            reply.header.rcode = dl.RCODE.SERVFAIL
        log.verbose("reply:\n%s" % (reply))
        return reply

    def resolve1(self, request):
        reply = request.reply(ra = 0, aa = 1)
        if request.q.qtype == dl.QTYPE.AXFR:
            reply.header.rcode = dl.RCODE.REFUSED
            return reply
        with self.zone.lock:
            additional = set()
            if request.q.qclass == dl.CLASS.IN:
                self.add_answer(reply, additional, request.q.qname)
            self.add_authority(reply, additional)
            # additional processing
            for name in additional:
                self.add_additional(reply, name, dl.QTYPE.A)
        return reply

    def add_answer(self, reply, additional, name, level = 0):
        #
        # The basic idea is to return all records that match the query.
        # Some complications are ANY queries, following CNAME, and
        # keeping track of names to put in the additional section.
        # Not all features are supported, like subdomain referral.
        #
        if level > 10:
            raise RuntimeError("CNAME loop in resolving %s" %
                               (str(reply.q.qname)))
        rds = self.zone.get(Zone.mklabel(str(name)), None)
        if rds is None:
            if level > 0:
                # not an error if we're just following CNAME
                reply.header.rcode = dl.RCODE.NXDOMAIN
            return
        qtype = reply.q.qtype
        for r in rds:
            if (qtype != dl.QTYPE.ANY and
                qtype != r[0] and
                r[0] != dl.QTYPE.CNAME):
                continue
            rr = dl.RR(rname = name,
                       rtype = r[0],
                       rclass = reply.q.qclass,
                       ttl = self.zone.ttl,
                       rdata = r[1])
            reply.add_answer(rr)
            if (r[0] == dl.QTYPE.CNAME and
                qtype != dl.QTYPE.CNAME and
                qtype != dl.QTYPE.ANY):
                self.add_answer(reply, additional, r[1].label, level + 1)
            elif r[0] == dl.QTYPE.NS or r[0] == dl.QTYPE.MX:
                additional |= {r[1].label}

    def add_authority(self, reply, additional):
        name = self.zone.origin
        for r in self.zone.get(name, []):
            if r[0] == dl.QTYPE.NS:
                rr = dl.RR(rname = name,
                           rtype = r[0],
                           rclass = reply.q.qclass,
                           ttl = self.zone.ttl,
                           rdata = r[1])
                reply.add_auth(rr)
                additional |= {r[1].label}

    def add_additional(self, reply, name, type):
        for r in self.zone.get(name, []):
            if r[0] == type:
                rr = dl.RR(rname = name,
                           rtype = r[0],
                           rclass = reply.q.qclass,
                           ttl = self.zone.ttl,
                           rdata = r[1])
                reply.add_ar(rr)

class CtrlServer(ss.TCPServer):
    allow_reuse_address = True
    def __init__(self, addr):
        super().__init__(addr, CtrlRequest, True)

    def start(self):
        log.info("listening on %s port %s ctrl" %
                 (self.server_address[0], self.server_address[1]))
        self.serve_forever()

class CtrlRequest(ss.StreamRequestHandler):
    def handle(self):
        try:
            request = self.rfile.readline().strip().decode("us-ascii")
            request = json.loads(request)
            log.verbose("ctrl: %s" % (json.dumps(request)))
            reply = self.handle1(request)
        except (TypeError, ValueError) as e:
            log.warning("%s" % traceback.format_exc())
            reply = (1, "Invalid request: %s" % (str(e)))
        except Exception as e:
            log.error("%s" % traceback.format_exc())
            reply = (10, str(e))
        try:
            reply = (json.dumps(reply) + "\n").encode("us-ascii")
            self.wfile.write(reply)
        except Exception as e:
            log.error("%s" % traceback.format_exc())

    def handle1(self, request):
        cmd, *args = request
        if cmd == "set":
            zone, name, type, value = args
            return self.set(zone, name, type, value)
        return (1, "Unknown request")

    def set(self, origin, name, type, value):
        zone = self.findzone(origin)
        if zone is None:
            return (1, "Unknown zone")
        if not zone.set(name, type, value):
            return (1, "Invalid resource type or value")
        return (0, "Success")

    def findzone(self, origin):
        return zones.get(Zone.mklabel(origin), None)

class Log(object):
    def __init__(self, name, opts):
        self.daemon = opts.daemon
        self.level = opts.verbose
        if self.daemon:
            syslog.openlog(name, 0, syslog.LOG_DAEMON)
    def _log(self, priority, msg):
        for line in msg.split("\n"):
            if line == "":
                continue
            if self.daemon:
                syslog.syslog(priority, line)
            else:
                print(line)
    def info(self, msg):
        self._log(syslog.LOG_INFO, msg)
    def warning(self, msg):
        self._log(syslog.LOG_WARNING, msg)
    def error(self, msg):
        self._log(syslog.LOG_ERR, msg)
    def verbose(self, msg):
        if self.level > 0:
            self._log(syslog.LOG_INFO, msg)
    def verbose2(self, msg):
        if self.level > 1:
            self._log(syslog.LOG_INFO, msg)

if __name__ == "__main__":
    try:
        exit(main())
    except KeyboardInterrupt:
        pass
    except Exception:
        if log:
            log.error("%s" % traceback.format_exc())
        else:
            traceback.print_exc()
    exit(1)
