#!/bin/sh

# Set PATH.
# This does two things:
#     1. Set the path for ourselves.
#     2. Give subprocesses a path.
#        While dash provides a default path if we are started
#        without one, it it not exported.  So do that here.

export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

mount -a

hostname `cat /etc/hostname`

syslogd -C512
klogd -c5

echo 5 >/proc/sys/kernel/panic

while read line; do
    line="${line%%#*}"
    [ -z "$line" ] || modprobe $line
done </etc/modules

(netd &)

# Bring up mdev to run storage manager
mkdir -p /tmp/lvm/etc
cp /etc/lvm/lvm.conf /tmp/lvm/etc
mount --bind /tmp/lvm/etc /etc/lvm
echo >/dev/mdev.seq
echo /sbin/mdev >/proc/sys/kernel/hotplug
mdev -s &

# Wait for storage to be mounted, if already provisioned
storaged -i0 -v
if [ $? -ne 0 ]; then
    echo No USB storage provisioned, starting docker on tmpfs
    dockerontmpfs=1
    mount /etc/docker
    mount -osize=256M /var/lib/docker
fi

# Start docker daemon
startdocker
if [ $dockerontmpfs ]; then
    mount -oremount /var/lib/docker
fi

# Provision and expand storage if needed
storaged -i1 -v
if [ $? -ne 0 ]; then
    echo No USB storage available, continuing without persistent storage
    # XXX sleep forever, don't bother going on?
else
    usbstore=1
fi

echo Starting zerotier
# XXX Need to put /var/lib/zerotier-one somewhere persistent, so we can
#     upgrade the ZT container.
chmod og+rw /dev/net/tun
if [ -f /boot/zerotier.conf ]; then
    . /boot/zerotier.conf

    if [ -n "$usbstore" ]; then
        mkdir -p /mnt/vol00/sysdata/zerotier/var-lib-zerotier-one
        MOUNT="-v /mnt/vol00/sysdata/zerotier/var-lib-zerotier-one:/mnt/var-lib-zerotier-one"
    fi

    docker run --rm -d --net=host \
           --cap-add=NET_ADMIN --cap-add=SYS_ADMIN --device=/dev/net/tun \
           $MOUNT --name zerotier zerotier
    # Run this in the foreground (for now) so we can see the network id.
    # Also, it makes zerotier startup more sychronous, which is nice
    # (for example, the loop below can have a shorter timeout).
    docker exec -it \
           -e ZEROTIER_AUTHORIZED_HOSTS="$ZEROTIER_AUTHORIZED_HOSTS" \
           zerotier /zerotier_allow.py private

    # XXX Give it a timeout for now, for debugging other parts of the system
    #     while zerotier is flaky.  It should always work, so that needs
    #     to be looked into.
    n=10
    while true; do
        ZTIF=`ip -o address | grep -Eo '^[0-9]+: zt.+ +inet +172\.18\.0\.1/' | cut -d' ' -f2`
        if [ -n "$ZTIF" ]; then
            echo "Zerotier interface $ZTIF"
            break;
        fi
        if [ $n -le 0 ]; then
            echo "Zerotier interface not found"
            break
        fi
        echo "Waiting for Zerotier interface to appear...$n"
        sleep 1
        n=$(($n - 1))
    done
fi

# Create default networks
#XXX Create a public network, and disable default/docker0
#XXX This should use --internal, so the container can't hit the internet, but
#    that breaks access to other hosts on the zerotier bridge.
docker network rm private >/dev/null 2>&1
docker network create --subnet=172.18.0.0/22 --ip-range=172.18.0.0/23 \
       -d macvlan -o parent=$ZTIF private

docker network rm appscontrol >/dev/null 2>&1
docker network create --driver=bridge appscontrol

echo Starting dnsd
runcontainer \
    -a --publish=53:53/tcp \
    -a --publish=53:53/udp \
    -a --cap-add=NET_BIND_SERVICE \
    -n +dnsdcontrol \
    dnsd dnsd -d

echo Starting web api service
#XXX Need to persist apikey/username on the SDCard.
touch /tmp/apikey /tmp/username
docker container create -t --net=private --ip 172.18.0.2 \
       -v /tmp/apikey:/apikey -v /tmp/username:/username --name web web
docker network connect --alias="apps-control" appscontrol web
docker container start web

#XXX Poll for dnsd readiness.
#Wait for APIkey/username to be valid.
n=100
while [ ! -s /tmp/apikey ] || [ ! -s /tmp/username ]; do
    if [ $n -le 0 ]; then
        break
    fi
    echo "Waiting for APIKEY/username...$n"
    n=$(($n - 1))
    sleep 5
done
USERNAME=`cat /tmp/username`
APIKEY=`cat /tmp/apikey`
if [ -z "$USERNAME" -o -z "$APIKEY" ]; then
    echo "Failed to get APIKEY/username"
    # XXX shouldn't just go on
fi

echo Starting app store
docker container create -t -v /mnt/vol00/appsdir:/appsdir -v /var/run/docker.sock:/var/run/docker.sock \
       --name apps apps python3 ./appserver.py "https://boundery.me/" $APIKEY $USERNAME.boundery.me
docker network connect --alias="apps-control" appscontrol apps
docker network connect --alias="dnsd-control" dnsdcontrol apps
docker container start apps

#Start the haproxy system container
echo Starting system haproxy
docker run -d --name haproxy haproxy

# XXX eventually this will be some form of getty
setsid -cw bash -l

docker kill apps
docker kill web
docker kill dnsd
docker kill zerotier
startdocker -k
storaged -u -v
netd -k
umount -a
sync
