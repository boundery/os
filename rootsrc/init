#!/bin/sh

# Set PATH.
# This does two things:
#     1. Set the path for ourselves.
#     2. Give subprocesses a path.
#        While dash provides a default path if we are started
#        without one, it it not exported.  So do that here.

export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

mount -a

hostname `cat /etc/hostname`

syslogd -C512
klogd -c5

echo 5 >/proc/sys/kernel/panic

while read line; do
    line="${line%%#*}"
    [ -z "$line" ] || modprobe $line
done </etc/modules

(netd &)

# Bring up mdev to run storage manager
mkdir -p /tmp/lvm/etc
cp /etc/lvm/lvm.conf /tmp/lvm/etc
mount --bind /tmp/lvm/etc /etc/lvm
echo >/dev/mdev.seq
echo /sbin/mdev >/proc/sys/kernel/hotplug
mdev -s &

# Wait for storage to be mounted, if already provisioned
storaged -i0 -v
if [ $? -ne 0 ]; then
    echo No USB storage provisioned, starting docker on tmpfs
    dockerontmpfs=1
    mount /etc/docker
    mount -osize=256M /var/lib/docker
fi

# Start docker daemon
startdocker
if [ $dockerontmpfs ]; then
    mount -oremount /var/lib/docker
fi

# Provision and expand storage if needed
storaged -i1 -v
if [ $? -ne 0 ]; then
    echo No USB storage available, continuing without persistent storage
    # XXX sleep forever, don't bother going on?
else
    usbstore=1
fi

echo Starting zerotier
chmod og+rw /dev/net/tun
if [ -n "$usbstore" ]; then
    mkdir -p /mnt/vol00/sysdata/zerotier/var-lib
    MOUNT="-v /mnt/vol00/sysdata/zerotier/var-lib:/mnt/var-lib-zerotier-one"
else
    echo "ERROR: No persistent storage for ZeroTier state!"
    #XXX Need a scheme to handle this!
fi

docker run --rm -d --net=host \
       --cap-add=NET_ADMIN --cap-add=SYS_ADMIN --device=/dev/net/tun \
       $MOUNT -v /boot/pairingkey:/pairingkey --name zerotier zerotier /start private
# Run this in the foreground (for now) so we can see the network id.
# Also, it makes zerotier startup more sychronous, which is nice.
docker exec -it \
       -e ZEROTIER_AUTHORIZED_HOSTS="$ZEROTIER_AUTHORIZED_HOSTS" \
       zerotier python3 /zerotier_allow.py private

while true; do
    ZTIF=`ip -o address | grep -Eo '^[0-9]+: zt.+ +inet +172\.18\.0\.1/' | cut -d' ' -f2`
    if [ -n "$ZTIF" ]; then
        echo "Zerotier interface $ZTIF"
        break;
    fi
    echo "Waiting for Zerotier interface to appear..."
    sleep 1
done
BOOTSTRAP_IPV6=`ip -o address | grep -Eo '^[0-9]+: zt.+ +inet6 fc[0-9a-f:]+/40 scope global' | grep -v " $ZTIF " | awk '{print $4}' | cut -d'/' -f1`

#Start registration container if needed.
if [ ! -s /boot/apikey ]; then
    mount -oremount,rw /boot
    touch /boot/apikey
    docker run --rm -v /boot/apikey:/apikey \
           -v /boot/pairingkey:/pairingkey \
           --name registration registration \
           python3 ./register.py "https://boundery.me" $BOOTSTRAP_IPV6 &
fi

# Create default networks
#XXX Create a public network, and disable default/docker0
#XXX This should use --internal, so the container can't hit the internet, but
#    that breaks access to other hosts on the zerotier bridge.
docker network rm private >/dev/null 2>&1
docker network create --subnet=172.18.0.0/22 --ip-range=172.18.0.0/23 \
       -d macvlan -o parent=$ZTIF private

docker network rm appscontrol >/dev/null 2>&1
docker network create --driver=bridge appscontrol

echo Starting dnsd
runcontainer \
    -a --publish=53:53/tcp \
    -a --publish=53:53/udp \
    -a --cap-add=NET_BIND_SERVICE \
    -n +dnsdcontrol \
    dnsd dnsd -d

echo Starting web api service
docker container create -t --net=private --ip 172.18.0.2 --name web web
docker network connect --alias="apps-control" appscontrol web
docker container start web

#XXX Poll for dnsd readiness.
#Wait for APIkey to be valid.
n=100
while [ ! -s /boot/apikey ]; do
    if [ $n -le 0 ]; then
        break
    fi
    echo "Waiting for APIKEY...$n"
    n=$(($n - 1))
    sleep 5
done
mount -oremount,ro /boot
APIKEY=`cat /boot/apikey`
if [ -z "$APIKEY" ]; then
    echo "Failed to get APIKEY"
    # XXX shouldn't just go on
fi

#XXX Stop here if we don't have persistent storage? Or try to find a way to
#    muddle on, and patch it up later if/when we do?
echo Starting app store
mkdir -p /mnt/vol00/sysdata/appstore/data
docker container create -t -v /mnt/vol00/sysdata/appstore/data:/data \
       -v /mnt/vol00/appsdir:/appsdir -v /var/run/docker.sock:/var/run/docker.sock \
       --name appstore appstore python3 ./appserver.py "https://boundery.me" "$APIKEY" boundery.me
docker network connect --alias="apps-control" appscontrol appstore
docker network connect --alias="dnsd-control" dnsdcontrol appstore
docker container start appstore

#Start the haproxy system container
echo Starting system haproxy
docker run -d --name haproxy haproxy

# XXX eventually this will be some form of getty
setsid -cw bash -l

docker kill appstore
docker kill web
docker kill dnsd
docker kill zerotier
startdocker -k
storaged -u -v
netd -k
umount -a
sync
